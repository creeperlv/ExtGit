using ExtGit.Core.FileHash;
using ExtGit.Core.Utilities;
using ExtGit.Localization;
using LibGit2Sharp;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Version = System.Version;

namespace ExtGit.Core.Version1
{
    public partial class Repo
    {
        public string RepoPath
        {
            get; private set;
        }
        public static Repository GitRepo;
        public static readonly Version CurrentConfigVer = new Version(1, 0, 1, 0);
        public static readonly Version MinConfigVer = new Version(1, 0, 1, 0);
        public Version ExtGitVer;
        public Version ExtGitVerCore;
        public long MaxFileSize = 1024 * 1024 * 99;//100MB is the max file size limit of GitHub. Must be align to 1 KB
        public bool AutoTrack = true;//Auto track files that overflow the limit.
        public double TraceTriggerLevel = 0.9;//MaxFile*TraceTriggerLevel is the actual detection-line.
        public bool IgnoreIgnoredFile = true;//Load .gitignore
        public List<string> AutoTraceFileTypes = new List<string>();//Although auto trace is enough, still provide a way to automatically trace files on file type.
        public List<string> AutoTraceFilePaths = new List<string>();//Although auto trace is enough, still provide a way to automatically trace files on file path.
        public List<string> IgnoredFilePaths = new List<string>();//Besides .gitignore, still can ignore some files incase that some auto-generated files will never reach the real limit but reaches the detection line.

        private List<TraceIndex> TracedFiles = new List<TraceIndex>();

        FileInfo ConfigurationFile;

        bool isTemplate = false;

        long realDetectionLine = 0;

        public Repo()
        {
            isTemplate = true;
        }
        public Repo(string RepoPath)
        {
            this.RepoPath = RepoPath;
            ConfigurationFile = new FileInfo(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Repo.extgit"));
            if (!ConfigurationFile.Exists)
            {
                throw new Exception(Language.CurrentLanguage.Get("ERROR_CODE00", "Target directory is not an ExtGit directory!"));
            }
            Repo.GitRepo = new Repository(Path.Combine(RepoPath, ".extgit"));
            Load();
            DirectoryInfo directoryInfo = new DirectoryInfo(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Traces"));
            var existedTraces = directoryInfo.EnumerateFiles();
            foreach (var item in existedTraces)
            {
                TracedFiles.Add(new TraceIndex(item, this));
            }
        }
        public static void Create(Repo r, string RepoPath)
        {
            Repository.Init(Path.Combine(RepoPath, ".extgit"));
            var ConfigurationFile = new FileInfo(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Repo.extgit"));
            if (!Directory.Exists(Path.Combine(RepoPath, ".extgit", ".extgitconf")))
            {
                Directory.CreateDirectory(Path.Combine(RepoPath, ".extgit", ".extgitconf"));
            }
            if (!Directory.Exists(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Traces")))
            {
                Directory.CreateDirectory(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Traces"));
            }
            if (!ConfigurationFile.Exists)
            {
                if (!ConfigurationFile.Directory.Exists)
                {
                    ConfigurationFile.Directory.Create();
                }
                ConfigurationFile.Create().Close();
            }
            {
                var ConFileContent = "#Generated By ExtGit.Core";
                ConFileContent += $"ExtGitVer={r.ExtGitVer}\r\n";
                ConFileContent += $"ExtGitCoreVer={r.ExtGitVerCore}\r\n";
                ConFileContent += $"MaxFileSize={r.MaxFileSize / 1024}\r\n";
                ConFileContent += $"AutoTrack={r.AutoTrack}\r\n";
                ConFileContent += $"TraceTriggerLevel={r.TraceTriggerLevel}\r\n";
                ConFileContent += $"IgnoreIgnoredFile={r.IgnoreIgnoredFile}\r\n";
                foreach (var item in r.AutoTraceFileTypes)
                {
                    ConFileContent += $"AutoTraceFileType={item}\r\n";
                }
                foreach (var item in r.AutoTraceFilePaths)
                {
                    ConFileContent += $"AutoTraceFilePath={item}\r\n";
                }
                foreach (var item in r.IgnoredFilePaths)
                {
                    ConFileContent += $"IgnoredFilePath={item}\r\n";
                }
                File.WriteAllText(ConfigurationFile.FullName, ConFileContent);
            }
        }
        void Load()
        {
            var content = File.ReadAllLines(ConfigurationFile.FullName);
            foreach (var item in content)
            {
                try
                {
                    if (item.StartsWith("ExtGitVer="))
                    {
                        ExtGitVer = Version.Parse(item.Substring("ExtGitVer=".Length));
                    }
                    else if (item.StartsWith("ExtGitCoreVer="))
                    {
                        ExtGitVerCore = Version.Parse(item.Substring("ExtGitCoreVer=".Length));
                    }
                    else if (item.StartsWith("MaxFileSize="))
                    {
                        MaxFileSize = long.Parse(item.Substring("MaxFileSize=".Length)) * 1024;
                    }
                    else if (item.StartsWith("AutoTrack="))
                    {
                        AutoTrack = bool.Parse(item.Substring("AutoTrack=".Length));
                    }
                    else if (item.StartsWith("TraceTriggerLevel="))
                    {
                        TraceTriggerLevel = double.Parse(item.Substring("TraceTriggerLevel=".Length));
                    }
                    else if (item.StartsWith("IgnoreIgnoredFile="))
                    {
                        IgnoreIgnoredFile = bool.Parse(item.Substring("IgnoreIgnoredFile=".Length));
                    }
                    else if (item.StartsWith("AutoTraceFileType="))
                    {
                        AutoTraceFileTypes.Add(item.Substring("AutoTraceFileType=".Length));
                    }
                    else if (item.StartsWith("AutoTraceFilePath="))
                    {
                        AutoTraceFilePaths.Add(item.Substring("AutoTraceFilePath=".Length));
                    }
                    else if (item.StartsWith("IgnoredFilePath="))
                    {
                        IgnoredFilePaths.Add(item.Substring("IgnoredFilePath=".Length));
                    }
                }
                catch (Exception)
                {
                }
            }
            realDetectionLine = (long)(((double)MaxFileSize) * TraceTriggerLevel);
        }
        public void Commit(ref double progress)
        {
            if (isTemplate == true)
            {
                throw new Exception(Language.CurrentLanguage.Get("ERROR_CODE01", "Current repository is a TEMPLATE repository!"));
            }
            //GitRepo.Ignore.IsPathIgnored()

            {
                //Will read all filses.
                CheckDirectory(new DirectoryInfo(RepoPath));
                DealWithTracedFileDeletion();
                DealTracesUpdate();
                //Finalize
                WipeUselessTraces();
            }
        }
        public void WipeUselessTraces()
        {
            foreach (var item in TracedFiles)
            {
                item.Urgent();
            }
        }
        public void DealWithTracedFileDeletion()
        {
            foreach (var item in TracedFiles)
            {
                var AssumedPath = Path.Combine(RepoPath, item.RelativeFilePath);
                if (!File.Exists(AssumedPath))
                {
                    Debugger.CurrentDebugger.Log($"Trace index \"{item.RelativeFilePath}\" is scheduled.");
                    item.Schedule();
                }
            }
        }
        public void DealTracesUpdate()
        {
            foreach (var item in TracedFiles)
            {
                item.DifferAndUpdate();
            }
        }
        public void CheckDirectory(DirectoryInfo directory)
        {
            Debugger.CurrentDebugger.Log($"Current Folder: {directory.FullName}", Utilities.LogLevel.Development);
            if (directory.FullName.ToUpper() == Path.Combine(RepoPath, ".extgit").ToUpper())
            {
                Debugger.CurrentDebugger.Log($"Folder: {directory.FullName} is ignored", Utilities.LogLevel.Development);
                //Don't self copy :P.
                return;
            }
            var RP = PathHelper.GetRelativePath(RepoPath, directory.FullName);
            {
                {
                    //Get Relative Path.
                    try
                    {
                        Debugger.CurrentDebugger.Log("Check:" + RP, Utilities.LogLevel.Development);
                        if (GitRepo.Ignore.IsPathIgnored(RP + Path.DirectorySeparatorChar))
                        {
                            return;
                        }
                    }
                    catch (Exception)
                    {
                    }
                }
            }
            {
                if (!Directory.Exists(Path.Combine(RepoPath, ".extgit", RP)))
                {
                    Directory.CreateDirectory(Path.Combine(RepoPath, ".extgit", RP));
                    Directory.SetCreationTime(Path.Combine(RepoPath, ".extgit", RP), directory.CreationTime);
                }
            }
            var DirectoriesInWorkLoad = new List<String>();
            {
                var Workload = Path.Combine(RepoPath, ".extgit", RP);
                DirectoryInfo directoryInfo = new DirectoryInfo(Workload);
                foreach (var item in directoryInfo.EnumerateDirectories())
                {
                    DirectoriesInWorkLoad.Add(item.Name);
                }
            }
            foreach (var item in directory.EnumerateDirectories())
            {
                if(DirectoriesInWorkLoad.Contains(item.Name))
                DirectoriesInWorkLoad.Remove(item.Name);
                Debugger.CurrentDebugger.Log($"Folder: {item.FullName}", Utilities.LogLevel.Development);
                CheckDirectory(item);
            }
            {
                foreach (var item in DirectoriesInWorkLoad)
                {
                    PathHelper.RemoveFolderR(new DirectoryInfo(Path.Combine(RepoPath, ".extgit", RP,item)));
                }
            }
            Debugger.CurrentDebugger.Log($"Deal with: {directory.FullName}", Utilities.LogLevel.Development);
            Directory.SetLastAccessTime(Path.Combine(RepoPath, ".extgit", RP), directory.LastAccessTime);
            Directory.SetLastWriteTime(Path.Combine(RepoPath, ".extgit", RP), directory.LastWriteTime);
            foreach (var item in directory.EnumerateFiles())
            {
                Debugger.CurrentDebugger.Log($"File: {item.FullName}", Utilities.LogLevel.Development);
                var FRP = PathHelper.GetRelativePath(RepoPath, item.FullName);
                var FAP = Path.Combine(RepoPath, ".extgit", FRP);
                Debugger.CurrentDebugger.Log($"File: RelatedPath:{FRP}", Utilities.LogLevel.Development);
                if (!File.Exists(FAP))
                {
                    //Check trace;
                    bool isTracked = false;
                    foreach (var titem in TracedFiles)
                    {
                        if (titem.RelativeFilePath == FRP)
                        {
                            Debugger.CurrentDebugger.Log($"Traced File:{titem.RelativeFilePath}, Now relative file:{FRP}", Utilities.LogLevel.Development);
                            isTracked = true;
                            break;
                        }
                    }
                    if (isTracked == false)
                    {
                        //File is not tracked.
                        // Detect weather to trace;
                        if (AutoTrack)
                        {
                            if (item.Length > realDetectionLine)
                            {
                                //Add to trace.
                                TracedFiles.Add(TraceIndex.TrackAndRecord(item, this));
                                isTracked = true;
                                //TraceIndex.Track(item, this);
                                continue;
                            }
                        }
                        foreach (var type in AutoTraceFileTypes)
                        {
                            if (item.FullName.ToUpper().EndsWith(type.ToUpper()))
                            {
                                TracedFiles.Add(TraceIndex.TrackAndRecord(item, this));
                                isTracked = true;
                                break;
                            }
                        }
                        if (isTracked == false)
                        {
                            item.CopyTo(FAP);
                        }
                    }
                    continue;
                }
                var NFHASH = SHA256Hash.ComputeSHA256(item.FullName);
                var OFHASH = SHA256Hash.ComputeSHA256(FAP);
                if (NFHASH == OFHASH)
                {
                    //the same file, ignore.
                    continue;
                }
            }
        }
        //public List<>
        public void Checkout(ref double progress)
        {
            if (isTemplate == true)
            {
                throw new Exception(Language.CurrentLanguage.Get("ERROR_CODE01", "Current repository is a TEMPLATE repository!"));
            }
            OverwriteDiretory(new DirectoryInfo(RepoPath));
            foreach (var item in TracedFiles)
            {
                item.CombineAndOverwrite();
            }
        }
        public void OverwriteDiretory(DirectoryInfo directory)
        {

            Debugger.CurrentDebugger.Log($"Current Folder: {directory.FullName}", Utilities.LogLevel.Development);
            if (directory.FullName.ToUpper() == Path.Combine(RepoPath, ".extgit").ToUpper())
            {
                Debugger.CurrentDebugger.Log($"Folder: {directory.FullName} is ignored", Utilities.LogLevel.Development);
                //Don't self copy :P.
                return;
            }
            var RP = PathHelper.GetRelativePath(RepoPath, directory.FullName);
            {
                {
                    //Get Relative Path.
                    try
                    {
                        Debugger.CurrentDebugger.Log("Check:" + RP, Utilities.LogLevel.Development);
                        if (GitRepo.Ignore.IsPathIgnored(RP + Path.DirectorySeparatorChar))
                        {
                            return;
                        }
                    }
                    catch (Exception)
                    {
                    }
                }
            }
            {
                if (!Directory.Exists(Path.Combine(RepoPath, ".extgit", RP)))
                {
                    PathHelper.RemoveFolderR(directory);
                    return;
                }
            }
            foreach (var item in directory.EnumerateDirectories())
            {
                Debugger.CurrentDebugger.Log($"Folder: {item.FullName}", Utilities.LogLevel.Development);
                CheckDirectory(item);
            }
            Debugger.CurrentDebugger.Log($"Deal with: {directory.FullName}", Utilities.LogLevel.Development);
            Directory.SetLastAccessTime(Path.Combine(RepoPath, ".extgit", RP), directory.LastAccessTime);
            Directory.SetLastWriteTime(Path.Combine(RepoPath, ".extgit", RP), directory.LastWriteTime);
            foreach (var item in directory.EnumerateFiles())
            {
                Debugger.CurrentDebugger.Log($"File: {item.FullName}", Utilities.LogLevel.Development);
                var FRP = PathHelper.GetRelativePath(RepoPath, item.FullName);
                var FAP = Path.Combine(RepoPath, ".extgit", FRP);
                Debugger.CurrentDebugger.Log($"File: RelatedPath:{FRP}", Utilities.LogLevel.Development);
                if (!File.Exists(FAP))
                {
                    //Check trace;
                    bool isTracked = false;
                    foreach (var titem in TracedFiles)
                    {
                        if (titem.RelativeFilePath == FRP)
                        {
                            Debugger.CurrentDebugger.Log($"Traced File:{titem.RelativeFilePath}, Now relative file:{FRP}", Utilities.LogLevel.Development);
                            isTracked = true;
                            break;
                        }
                    }
                    if (isTracked == false)
                    {
                        item.Delete();
                    }
                    continue;
                }
                var NFHASH = SHA256Hash.ComputeSHA256(item.FullName);
                var OFHASH = SHA256Hash.ComputeSHA256(FAP);
                if (NFHASH == OFHASH)
                {
                    //the same file, ignore.
                    continue;
                }
                //Different File.
                //Overwrite.
                File.Copy(FAP, item.FullName, true);
            }
        }

    }
}
