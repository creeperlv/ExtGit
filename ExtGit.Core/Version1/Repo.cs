using ExtGit.Core.FileHash;
using ExtGit.Core.Utilities;
using ExtGit.Localization;
using LibGit2Sharp;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Version = System.Version;

namespace ExtGit.Core.Version1
{
    public class Repo
    {
        public string RepoPath
        {
            get; private set;
        }
        public static Repository GitRepo;
        public static readonly Version CurrentConfigVer = new Version(1, 0, 1, 0);
        public static readonly Version MinConfigVer = new Version(1, 0, 1, 0);
        public Version ExtGitVer;
        public Version ExtGitVerCore;
        public long MaxFileSize = 1024 * 1024 * 99;//100MB is the max file size limit of GitHub.
        public bool AutoTrack = true;//Auto track files that overflow the limit.
        public double TraceTriggerLevel = 0.9;//MaxFile*TraceTriggerLevel is the actual detection-line.
        public bool IgnoreIgnoredFile = true;//Load .gitignore
        public List<string> AutoTraceFileTypes = new List<string>();//Although auto trace is enough, still provide a way to automatically trace files on file type.
        public List<string> AutoTraceFilePaths = new List<string>();//Although auto trace is enough, still provide a way to automatically trace files on file path.
        public List<string> IgnoredFilePaths = new List<string>();//Besides .gitignore, still can ignore some files incase that some auto-generated files will never reach the real limit but reaches the detection line.

        private List<TraceIndex> TracedFiles = new List<TraceIndex>();

        FileInfo ConfigurationFile;

        bool isTemplate = false;

        long realDetectionLine = 0;

        public Repo()
        {
            isTemplate = true;
        }
        public Repo(string RepoPath)
        {
            this.RepoPath = RepoPath;
            ConfigurationFile = new FileInfo(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Repo.extgit"));
            Repo.GitRepo = new Repository(Path.Combine(RepoPath, ".extgit"));
            if (!ConfigurationFile.Exists)
            {
                throw new Exception(Language.CurrentLanguage.Get("ERROR_CODE00", "Target directory is not an ExtGit directory!"));
            }
            Load();
            DirectoryInfo directoryInfo = new DirectoryInfo(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Traces"));
            var existedTraces = directoryInfo.EnumerateFiles();
            foreach (var item in existedTraces)
            {
                TracedFiles.Add(new TraceIndex(item, this));
            }
        }
        public static void Create(Repo r, string RepoPath)
        {
            var ConfigurationFile = new FileInfo(Path.Combine(RepoPath, ".extgit", ".extgitconf", "Repo.extgit"));
            {
                var ConFileContent = "#Generated By ExtGit.Core";
                ConFileContent += $"ExtGitVer={r.ExtGitVer}\r\n";
                ConFileContent += $"ExtGitCoreVer={r.ExtGitVerCore}\r\n";
                ConFileContent += $"MaxFileSize={r.MaxFileSize}\r\n";
                ConFileContent += $"AutoTrack={r.AutoTrack}\r\n";
                ConFileContent += $"TraceTriggerLevel={r.TraceTriggerLevel}\r\n";
                ConFileContent += $"IgnoreIgnoredFile={r.IgnoreIgnoredFile}\r\n";
                foreach (var item in r.AutoTraceFileTypes)
                {
                    ConFileContent += $"AutoTraceFileType={item}\r\n";
                }
                foreach (var item in r.AutoTraceFilePaths)
                {
                    ConFileContent += $"AutoTraceFilePath={item}\r\n";
                }
                foreach (var item in r.IgnoredFilePaths)
                {
                    ConFileContent += $"IgnoredFilePath={item}\r\n";
                }
                File.WriteAllText(ConfigurationFile.FullName, ConFileContent);
            }
        }
        void Load()
        {
            var content = File.ReadAllLines(ConfigurationFile.FullName);
            foreach (var item in content)
            {
                try
                {
                    if (item.StartsWith("ExtGitVer="))
                    {
                        ExtGitVer = Version.Parse(item.Substring("ExtGitVer=".Length));
                    }
                    else if (item.StartsWith("ExtGitCoreVer="))
                    {
                        ExtGitVerCore = Version.Parse(item.Substring("ExtGitCoreVer=".Length));
                    }
                    else if (item.StartsWith("MaxFileSize="))
                    {
                        MaxFileSize = long.Parse(item.Substring("MaxFileSize=".Length));
                    }
                    else if (item.StartsWith("AutoTrack="))
                    {
                        AutoTrack = bool.Parse(item.Substring("AutoTrack=".Length));
                    }
                    else if (item.StartsWith("TraceTriggerLevel="))
                    {
                        TraceTriggerLevel = double.Parse(item.Substring("TraceTriggerLevel=".Length));
                    }
                    else if (item.StartsWith("IgnoreIgnoredFile="))
                    {
                        IgnoreIgnoredFile = bool.Parse(item.Substring("IgnoreIgnoredFile=".Length));
                    }
                    else if (item.StartsWith("AutoTraceFileType="))
                    {
                        AutoTraceFileTypes.Add(item.Substring("AutoTraceFileType=".Length));
                    }
                    else if (item.StartsWith("AutoTraceFilePath="))
                    {
                        AutoTraceFilePaths.Add(item.Substring("AutoTraceFilePath=".Length));
                    }
                    else if (item.StartsWith("IgnoredFilePath="))
                    {
                        IgnoredFilePaths.Add(item.Substring("IgnoredFilePath=".Length));
                    }
                }
                catch (Exception)
                {
                }
            }
            realDetectionLine = (long)(((double)MaxFileSize) * TraceTriggerLevel);
        }
        public void Commit(ref double progress)
        {
            if (isTemplate == true)
            {
                throw new Exception(Language.CurrentLanguage.Get("ERROR_CODE01", "Current repository is a TEMPLATE repository!"));
            }
            //GitRepo.Ignore.IsPathIgnored()

            {
                //Will read all filses.
                CheckDirectory(new DirectoryInfo(RepoPath));
                DealTracesUpdate();
            }
        }
        public void DealTracesUpdate()
        {

        }
        public void CheckDirectory(DirectoryInfo directory)
        {
            if (directory.FullName.ToUpper() == Path.Combine(RepoPath, ".extgit").ToUpper())
            {
                //Don't self copy :P.
                return;
            }
            var RP = PathHelper.GetRelativePath(RepoPath, directory.FullName);
            {
                {
                    //Get Relative Path
                    if (GitRepo.Ignore.IsPathIgnored(RP))
                    {
                        return;
                    }
                }
            }
            {
                if (!Directory.Exists(Path.Combine(RepoPath, ".extgit", RP)))
                {
                    Directory.CreateDirectory(Path.Combine(RepoPath, ".extgit", RP));
                    Directory.SetCreationTime(Path.Combine(RepoPath, ".extgit", RP), directory.CreationTime);
                }
            }
            foreach (var item in directory.EnumerateDirectories())
            {
                CheckDirectory(item);
            }
            Directory.SetLastAccessTime(Path.Combine(RepoPath, ".extgit", RP), directory.LastAccessTime);
            Directory.SetLastWriteTime(Path.Combine(RepoPath, ".extgit", RP), directory.LastWriteTime);
            foreach (var item in directory.EnumerateFiles())
            {
                var FRP = PathHelper.GetRelativePath(RepoPath, item.FullName);
                var FAP = Path.Combine(RepoPath, ".extgit", FRP);
                if (!File.Exists(FAP))
                {
                    //Check trace;
                    foreach (var titem in TracedFiles)
                    {
                        if (titem.RelativeFilePath == FRP)
                        {
                            break;
                        }
                    }
                    {
                        //File is not tracked.
                        // Detect weather to trace;
                        if (AutoTrack)
                        {
                            if (item.Length > realDetectionLine)
                            {
                                //Add to trace.
                                TraceIndex.Track(item, this);
                            }
                        }
                    }
                    continue;
                }
                var NFHASH = SHA256.ComputeSHA256(item.FullName);
                var OFHASH = SHA256.ComputeSHA256(FAP);
                if (NFHASH == OFHASH)
                {
                    //the same file, ignore.
                    continue;
                }
            }
        }
        //public List<>
        public void Checkout(ref double progress)
        {
            if (isTemplate == true)
            {
                throw new Exception(Language.CurrentLanguage.Get("ERROR_CODE01", "Current repository is a TEMPLATE repository!"));
            }
        }
    }
}
